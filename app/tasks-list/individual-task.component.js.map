{"version":3,"file":"individual-task.component.js","sourceRoot":"","sources":["individual-task.component.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,qBAA6C,eAAe,CAAC,CAAA;AAE7D,8BAA6B,2BAA2B,CAAC,CAAA;AAUzD;IAEC,wBAAoB,YAA0B;QAA1B,iBAAY,GAAZ,YAAY,CAAc;QAE9C,YAAO,GAAY,KAAK,CAAC;QACzB,gBAAW,GAAW,EAAE,CAAC;IAHwB,CAAC;IAKlD,iCAAQ,GAAR,UAAS,OAAoB;QAC5B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;QAClC,yEAAyE;QACzE,2EAA2E;QAC3E,UAAU,CAAC;YACV,OAAO,CAAC,KAAK,EAAE,CAAC;QACjB,CAAC,EAAE,CAAC,CAAC,CAAC;IACP,CAAC;IAED,iCAAQ,GAAR;QACG,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YACpB,IAAI,OAAO,GAAW,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;YAC9C,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBACtD;;;yDAGyC;gBACzC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC;gBAEzB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACrD,CAAC;YACD,IAAI,CAAC,WAAW,EAAE,CAAC;QACpB,CAAC;IACF,CAAC;IAED,oCAAW,GAAX;QACC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACtB,CAAC;IAED,mCAAU,GAAV;QACC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzC,CAAC;IAtCD;QAAC,YAAK,EAAE;;gDAAA;IART;QAAC,gBAAS,CAAC;YACV,QAAQ,EAAE,MAAM,CAAC,EAAE;YACnB,QAAQ,EAAE,oBAAoB;YAC9B,WAAW,EAAE,kCAAkC;SAC/C,CAAC;QAED,iBAAU,EAAE;;sBAAA;IAyCb,qBAAC;AAAD,CAAC,AAxCD,IAwCC;AAxCY,sBAAc,iBAwC1B,CAAA","sourcesContent":["import { Component, Input, Injectable } from '@angular/core';\r\nimport { ITask } from './task';\r\nimport { TasksService } from '../services/tasks-service';\r\n\r\n\r\n@Component({\r\n\tmoduleId: module.id,\r\n\tselector: 'al-individual-task',\r\n\ttemplateUrl: './individual-task.component.html'\r\n})\r\n\r\n@Injectable()\r\nexport class IndividualTask {\r\n\t@Input() task: ITask;\r\n\tconstructor(private tasksService: TasksService) {}\r\n\r\n\tediting: boolean = false;\r\n\teditingName: string = '';\r\n\r\n\teditName(element: HTMLElement): void {\r\n\t\tthis.editing = true;\r\n\t\tthis.editingName = this.task.name;\r\n\t\t//have to wait until the element is unhidden before it can receive focus.\r\n\t\t//This is a little bit hacky- see if you can find a way to not use timeouts\r\n\t\tsetTimeout(():void => {\r\n\t\t\telement.focus();\r\n\t\t}, 0);\r\n\t}\r\n\r\n\tsaveName(): void {\r\n\t\t  if (this.editing) {\r\n\t\t\tlet newName: string = this.editingName.trim();\r\n\t\t\tif (newName.length > 0 && newName !== this.task.name) {\r\n\t\t\t\t/*Update the task name here so it looks seamless to the user\r\n\t\t\t\t If there is a server error when it tries to update, the\r\n\t\t\t\t tasksService will still push out the old tasks list\r\n\t\t\t\t and the change will be reverted then. */\r\n\t\t\t\tthis.task.name = newName;\r\n\r\n\t\t\t\tthis.tasksService.updateTask(newName, this.task.id);\r\n\t\t\t}\r\n\t\t\tthis.stopEditing();\r\n\t\t}\r\n\t}\r\n\r\n\tstopEditing(): void {\r\n\t\tthis.editing = false;\r\n\t}\r\n\r\n\tdeleteTask(): void {\r\n\t\tthis.tasksService.deleteTask(this.task);\r\n\t}\r\n}"]}